C51 COMPILER V9.54   MAIN                                                                  11/07/2025 16:46:23 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\0_SoftWare\Keil5\C51\BIN\C51.EXE src\main.c LARGE OMF2 OPTIMIZE(0,SPEED) BROWSE DEBUG PRINT(.\Li
                    -stings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "global.h"
   2          #include "stack.h"
   3          #include "xstack.h"
   4          #include "scheduler.h"
   5          #include "bit_ops.h"
   6          #include "timer0_isr.h"
   7          #include "syscall.h"
   8          #include "semaphore.h"
   9          #include "events.h"
  10          #include "seg_led.h"
  11          #include "button.h"
  12          #include "usbcom.h"
  13          #include "rs485.h"
  14          #include "random.h"
  15          
  16          #define TIMESLICE_MS  1
  17          #define T12RL   (65536 - MAIN_Fosc*TIMESLICE_MS/12/1000) 
  18          /*
  19          点格棋
  20          
  21          交互功能：
  22          导航左右键 - 更新位选
  23          导航上下键 - 更新段选
  24          key3 - 确定位置
  25          
  26          编码规则：
  27          共8个字节
  28          第0,1字节为 aa 55
  29          第2字节为功能位
  30          00 -- 更新棋盘
  31            此时为棋盘更新
  32            aa 55 00 xa xb xx xx xx xa为位选 xb为段选
  33          01 -- 此时为结束，由某一个单片机发送数据后，另一个单片机返回数据
  34            aa 55 01 xa xb xx xx xx xa为本机地址 xb为分数
  35          */
  36          
  37          unsigned char head[2] = {0xaa, 0x55};
  38          unsigned char* buf;
  39          xdata unsigned char local_addr = 0x01; // 本机地址
  40          xdata unsigned char target_addr = 0x00; // 目标机地址 
  41          xdata unsigned char chess_board[8] = {0,0,0,0,0,0,0,0}; // 棋盘
  42          xdata unsigned char play_turn = 0; // 当前正在下棋的地址
  43          xdata unsigned char d_cur=0,w_cur=0; // 当前的游标位置（段选）和数码管位置（位选）
  44          xdata unsigned char spark = 0; // 闪烁的标志位，每1s更新一次
  45          xdata unsigned char send_data[8]; // 要发送的数据
  46          xdata unsigned char score = 0x00, target_score=0; // 本机分数和目标机分数
  47          xdata unsigned char is_end = 0; // 判断是否结束
  48          
  49          void setSendData(unsigned char s0,unsigned char s1,unsigned char s2,unsigned char s3,unsigned char s4,unsi
             -gned char s5,unsigned char s6,unsigned char s7){
  50   1        send_data[0] = s0;
  51   1        send_data[1] = s1;
  52   1        send_data[2] = s2;
  53   1        send_data[3] = s3;
C51 COMPILER V9.54   MAIN                                                                  11/07/2025 16:46:23 PAGE 2   

  54   1        send_data[4] = s4;
  55   1        send_data[5] = s5;
  56   1        send_data[6] = s6;
  57   1        send_data[7] = s7;
  58   1      }
  59          
  60          void update_w_cur(unsigned char dir){
  61   1        if(dir == 1){
  62   2          w_cur = (w_cur+1)%8;
  63   2          while(chess_board[w_cur] == 0x7f)w_cur = (w_cur+1)%8;
  64   2        }
  65   1        else if(dir == 0){
  66   2          if(w_cur == 0)w_cur = 7;
  67   2          else w_cur--;
  68   2      
  69   2          while(chess_board[w_cur] == 0x7f){
  70   3            if(w_cur == 0)w_cur = 7;
  71   3            else w_cur--;
  72   3          }
  73   2        }
  74   1      }
  75          
  76          void update_d_cur(unsigned char dir){
  77   1        if(dir == 1){
  78   2          if(d_cur == 0)d_cur = 6;
  79   2          else d_cur--;
  80   2      
  81   2          while((chess_board[w_cur]&(1<<d_cur)) == (1<<d_cur)){
  82   3            if(d_cur == 0)d_cur = 6;
  83   3            else d_cur--;
  84   3          }
  85   2        }
  86   1        else if(dir == 0){
  87   2          d_cur = (d_cur+1)%7;
  88   2          while((chess_board[w_cur]&(1<<d_cur)) == (1<<d_cur))d_cur = (d_cur+1)%7;
  89   2        }
  90   1      }
  91          
  92          unsigned char check_board_is_full(){ // 检查棋盘是否占满
  93   1        u8 i = 0;
  94   1        for(i=0;i<8;i++){
  95   2          if(chess_board[i]!=0x7f)return 0;
  96   2        }
  97   1        return 1;
  98   1      }
  99          
 100          unsigned char check_state(unsigned char w_cur, unsigned char d_cur){
 101   1        if(d_cur == 0 || d_cur == 1 || d_cur == 5){
 102   2          return ((chess_board[w_cur] & 0x63) == 0x63);
 103   2        }
 104   1        else if(d_cur == 2 || d_cur == 3 || d_cur == 4){
 105   2          return ((chess_board[w_cur] & 0x5c) == 0x5c);
 106   2        }
 107   1        else if(d_cur == 6){
 108   2          return ((chess_board[w_cur] & 0x63) == 0x63)+((chess_board[w_cur] & 0x5c) == 0x5c);
 109   2        }
 110   1        else return 0;
 111   1      }
 112          
 113          void myproc(u16 param) large reentrant{
 114   1        while(1){
 115   2          proc_wait_evts(EVT_BTN1_DN | EVT_BTN2_DN | EVT_BTN3_DN | EVT_NAV_L | EVT_NAV_R | EVT_NAV_U | EVT_NAV_D |
C51 COMPILER V9.54   MAIN                                                                  11/07/2025 16:46:23 PAGE 3   

             - EVT_NAV_PUSH | EVT_UART1_RECV | EVT_UART2_RECV);
 116   2          if((MY_EVENTS & EVT_UART2_RECV) == EVT_UART2_RECV){ // uart2
 117   3            if(rs485_buf[0] == 0xaa && rs485_buf[1] == 0x55){
 118   4              if(rs485_buf[2] == 0x00){ // 更新棋盘
 119   5                chess_board[rs485_buf[3]] |= (1<<rs485_buf[4]);
 120   5                
 121   5                // 如果没有形成闭环，进入我的回合
 122   5                if(check_state(rs485_buf[3], rs485_buf[4]) == 0){
 123   6                  play_turn = local_addr;
 124   6                  if(chess_board[w_cur] == 0x7f) update_w_cur(1);
 125   6                  if((chess_board[w_cur] & (1<<d_cur)) == (1<<d_cur)) update_d_cur(1);
 126   6                }
 127   5              }
 128   4              else if(rs485_buf[2] == 0x01){ // 结束
 129   5                target_score = rs485_buf[4];
 130   5                is_end = 1;
 131   5              }
 132   4            }
 133   3          }
 134   2      
 135   2          // 仅在当前是本机回合的时候，导航按键和key3才有效
 136   2          if(play_turn == local_addr){
 137   3            if((MY_EVENTS & EVT_NAV_L) == EVT_NAV_L){ // left
 138   4              update_w_cur(0);
 139   4              if((chess_board[w_cur]&(1<<d_cur)) == (1<<d_cur)) update_d_cur(1);
 140   4            }
 141   3            else if((MY_EVENTS & EVT_NAV_R) == EVT_NAV_R){ // right
 142   4              update_w_cur(1);
 143   4              if((chess_board[w_cur]&(1<<d_cur)) == (1<<d_cur)) update_d_cur(1);
 144   4            }
 145   3            else if((MY_EVENTS & EVT_NAV_U) == EVT_NAV_U){ // up
 146   4              update_d_cur(1);
 147   4            }
 148   3            else if((MY_EVENTS & EVT_NAV_D) == EVT_NAV_D){ // down
 149   4              update_d_cur(0);
 150   4            }
 151   3            else if((MY_EVENTS & EVT_BTN3_DN) == EVT_BTN3_DN){ // key3
 152   4              chess_board[w_cur] |= (1<<d_cur);
 153   4      
 154   4              if(check_board_is_full()){ // 棋盘已满，进入结算
 155   5                if(d_cur == 6)score+=2; // 更新后棋盘满，一定有一个形成闭环
 156   5                else score++;
 157   5                
 158   5                setSendData(0xaa,0x55,0x01,local_addr,score,0,0,0);
 159   5                rs485_write(send_data, 8);
 160   5      
 161   5                is_end = 1;
 162   5              }
 163   4              else{ // 棋盘未满，更新显示，继续游戏
 164   5                if(check_state(w_cur, d_cur)){ // 如果形成闭环，继续游戏
 165   6                  score=score+check_state(w_cur, d_cur);
 166   6                }
 167   5                else{
 168   6                  play_turn = target_addr; // 没有闭环，更换回合
 169   6                }
 170   5      
 171   5                setSendData(0xaa,0x55,0x00,w_cur,d_cur,0x00,0x00,0x00);
 172   5                rs485_write(send_data, 8);
 173   5      
 174   5                if(chess_board[w_cur] == 0x7f) update_w_cur(1); // 棋盘更新后更新显示位置
 175   5                if((chess_board[w_cur] & (1<<d_cur)) == (1<<d_cur))update_d_cur(1);
 176   5              }
C51 COMPILER V9.54   MAIN                                                                  11/07/2025 16:46:23 PAGE 4   

 177   4            }
 178   3            else if((MY_EVENTS & EVT_NAV_PUSH) == EVT_NAV_PUSH){ // center
 179   4      
 180   4            }
 181   3          }
 182   2        }
 183   1      }
*** WARNING C280 IN LINE 113 OF src\main.c: 'param': unreferenced local variable
 184          
 185          void timeproc(u16 param) large reentrant{
 186   1        u8 i = 0;
 187   1        while(1){
 188   2      
 189   2          if(i%10 == 0){}
 190   2          if(i%100 == 0){
 191   3            if(is_end == 0){
 192   4              if(play_turn == local_addr){ // 当前是本机回合
 193   5                setSegDir(chess_board[0],chess_board[1],chess_board[2],chess_board[3],chess_board[4],chess_board[5],c
             -hess_board[6],chess_board[7]);
 194   5                if(spark == 1){
 195   6                  setSegAdd(w_cur, d_cur);
 196   6                }
 197   5                led_display_content = score;
 198   5              }
 199   4              else{ // 当前不是本机回合
 200   5                setSegDir(chess_board[0],chess_board[1],chess_board[2],chess_board[3],chess_board[4],chess_board[5],c
             -hess_board[6],chess_board[7]);
 201   5              }
 202   4            }
 203   3            else if(is_end == 1){
 204   4              target_score = 16 - score;
 205   4              setSeg(46,46,score/10,score%10,46,46,target_score/10,target_score%10);
 206   4              led_display_content = 0x00;
 207   4            }
 208   3      
 209   3          }
 210   2          if(i%1000 == 0){
 211   3            spark = (1 - spark);
 212   3          }
 213   2          proc_sleep(1);
 214   2          i++;
 215   2        }
 216   1      }
*** WARNING C280 IN LINE 185 OF src\main.c: 'param': unreferenced local variable
 217          
 218          main()
 219          {
 220   1        //initialize kernel stack and xstack pointer
 221   1        SP = kernel_stack;
 222   1        setxbp(kernel_xstack + KERNEL_XSTACKSIZE);
*** WARNING C214 IN LINE 222 OF src\main.c: 'Argument': conversion: pointer to non-pointer
 223   1        
 224   1        //set process stacks and swap stacks owner
 225   1        process_stack[0][PROCESS_STACKSIZE-1] = 0;
 226   1        process_stack[1][PROCESS_STACKSIZE-1] = 1;
 227   1        process_stack[2][PROCESS_STACKSIZE-1] = 2;
 228   1        process_stack[3][PROCESS_STACKSIZE-1] = 3;
 229   1        process_stack[4][PROCESS_STACKSIZE-1] = 4;
 230   1        process_stack_swap[0][PROCESS_STACKSIZE-1] = 5;
 231   1        process_stack_swap[1][PROCESS_STACKSIZE-1] = 6;
 232   1        process_stack_swap[2][PROCESS_STACKSIZE-1] = 7;
 233   1        
C51 COMPILER V9.54   MAIN                                                                  11/07/2025 16:46:23 PAGE 5   

 234   1        //initialize LED pins
 235   1        P0M1 &= 0x00;
 236   1        P0M0 |= 0xff;
 237   1        P2M1 &= 0xf0;
 238   1        P2M0 |= 0x0f;
 239   1        //select LED, set all off
 240   1        P23 = 1;
 241   1        P0 = 0;
 242   1      
 243   1        //initialize buttons
 244   1        buttons_init();
 245   1        
 246   1        //initialize serial ports
 247   1        usbcom_init(9600);
 248   1        rs485_init(9600);
 249   1      
 250   1        setUartBuf(8, head, 2);
 251   1          
 252   1        //start process
 253   1        start_process(myproc, 0, 0);
 254   1        start_process(timeproc, 1, 0);
 255   1          
 256   1          
 257   1        //initialize PCA2 interrupt (as syscall interrupt)
 258   1        //clear CCF2
 259   1        CCON &= ~0x04;
 260   1        //disable PCA2 module and set ECCF2
 261   1        CCAPM2 = 1;
 262   1        //low priority interrupt
 263   1        PPCA = 0;
 264   1        
 265   1        //start main timer
 266   1        TR0 = 0;                            //stop timer
 267   1        TMOD &= 0xF0;                       //timer mode, 16b autoreload
 268   1        AUXR &= 0x7F;                       //12T mode
 269   1        TL0 = T12RL & 0xff;             //set reload value
 270   1        TH0 = (T12RL & 0xff00) >> 8;
 271   1        ET0 = EA = 1;                       //set interrupt enable
 272   1        PT0 = 0;                            //set priority to low
 273   1        TR0 = 1;                            //start timer
 274   1        
 275   1        //spin
 276   1        while(1);
 277   1      }
*** WARNING C291 IN LINE 111 OF src\main.c: not every exit path returns a value
*** WARNING C294 IN LINE 183 OF src\main.c: unreachable code
*** WARNING C294 IN LINE 183 OF src\main.c: unreachable code
*** WARNING C294 IN LINE 216 OF src\main.c: unreachable code
*** WARNING C294 IN LINE 216 OF src\main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2806    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     43    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
C51 COMPILER V9.54   MAIN                                                                  11/07/2025 16:46:23 PAGE 6   

   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  8 WARNING(S),  0 ERROR(S)
