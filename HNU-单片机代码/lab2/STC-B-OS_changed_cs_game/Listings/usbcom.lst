C51 COMPILER V9.54   USBCOM                                                                10/27/2025 12:51:22 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE USBCOM
OBJECT MODULE PLACED IN .\Objects\usbcom.obj
COMPILER INVOKED BY: D:\0_SoftWare\Keil5\C51\BIN\C51.EXE src\usbcom.c LARGE OMF2 OPTIMIZE(0,SPEED) BROWSE DEBUG PRINT(.\
                    -Listings\usbcom.lst) TABS(2) OBJECT(.\Objects\usbcom.obj)

line level    source

   1          #include "usbcom.h"
   2          
   3          
   4          void usbcom_init(u32 baudrate) 
   5          {
   6   1          XDATA u16 reload;
   7   1        
   8   1          //Set TXD(P31) to Push-Pull RXD(P30) to HiZ
   9   1          {
  10   2          CLEARBIT(P3M1, 1);
  11   2          SETBIT(P3M0, 1);
  12   2          
  13   2          SETBIT(P3M1, 0);
  14   2          CLEARBIT(P3M0, 0);
  15   2        }
  16   1      
  17   1          //Configure baudrate timer
  18   1          {
  19   2              reload = 65536 - (MAIN_Fosc / 4) / baudrate;
  20   2              
  21   2              AUXR |= 0x01;   //S1 BRT Use Timer2;
  22   2              AUXR &= ~(1<<4);  //Timer stop
  23   2              AUXR &= ~(1<<3);  //Timer2 set As Timer
  24   2              AUXR |=  (1<<2);  //Timer2 set as 1T mode
  25   2              IE2  &= ~(1<<2);  //Disable interrup
  26   2      
  27   2              TH2 = (u8)(reload>>8);
  28   2              TL2 = (u8)reload;
  29   2              AUXR |=  (1<<4);  //Timer run enable
  30   2          }
  31   1      
  32   1      
  33   1          //Initialize UART1 on P30 and P31
  34   1          {
  35   2              PS = 1; //High priority interrupt
  36   2              SCON = (SCON & 0x3f) | (1<<6); //8bit mode
  37   2              REN = 1; //Enable Rx
  38   2              P_SW1 = (P_SW1 & 0x3f) | (0 & 0xc0);  //Select IO port P30/P31
  39   2              ES = 1; //Enable interrupt (wait for incoming data)
  40   2          }
  41   1      
  42   1      }
  43          
  44          
  45          //this function blocks current process until all data is sent
  46          //not a VFUNC because there's no reentrancy support
  47          void __usbcom_write(u8* buf, u8 len) small
  48          {
  49   1          u8 i;
  50   1        
  51   1          //Disable interrupt (Tx uses polling mode)
  52   1          ES = 0;
  53   1      
  54   1          //length is set
C51 COMPILER V9.54   USBCOM                                                                10/27/2025 12:51:22 PAGE 2   

  55   1          if(len)
  56   1          {
  57   2            for(i=0;i<len;i++)
  58   2            {
  59   3                //clear TX end flag
  60   3                TI = 0;
  61   3                //feed byte into UART1 buffer
  62   3                SBUF = buf[i];
  63   3                //spin until TX end flag is set (by hardware)
  64   3                while(TI == 0);
  65   3            }
  66   2          }
  67   1          else
  68   1          {
  69   2            //length is 0, auto detect '\0'
  70   2            for(i=0;;i++)
  71   2            {
  72   3                //clear TX end flag
  73   3                TI = 0;
  74   3                //feed byte into UART1 buffer
  75   3                if(buf[i] == '\0') break;   
  76   3                SBUF = buf[i];
  77   3                //spin until TX end flag is set (by hardware)
  78   3                while(TI == 0);
  79   3            }
  80   2          }
  81   1          //Enable UART1 interrupt
  82   1          //(Rx uses interrupt to trigger, but still runs in polling mode)
  83   1          RI = 0;//Reset all flags
  84   1          TI = 0;
  85   1          ES = 1;
  86   1      }
  87          
  88          XDATA u8 usbcom_buf[64];
  89          XDATA u8 _copy_buf[64];
  90          XDATA char _buf_size = 0;
  91          XDATA char* _head;
  92          XDATA char _head_size = 0;
  93          
  94          void setUartBuf(char buf_size, char* head, char head_size){
  95   1          _buf_size = buf_size;
  96   1          _head = head;
  97   1          _head_size = head_size;
  98   1      }
  99          
 100          char _check_head(){
 101   1          u8 i;
 102   1          for(i=0;i<_head_size;i++){
 103   2              if(_head[i] != usbcom_buf[i])return 0;
 104   2          }
 105   1          return 1;
 106   1      }
 107          
 108          void* readBuf(){
 109   1          u8 i=0;
 110   1          if(_check_head()){
 111   2              for(i=0;i<64;i++)_copy_buf[i] = usbcom_buf[i];
 112   2              return _copy_buf;
 113   2          }
 114   1          else {return ((void*)0);}
 115   1      }
 116          
C51 COMPILER V9.54   USBCOM                                                                10/27/2025 12:51:22 PAGE 3   

 117          
 118          XDATA u8 usbcom_rxcnt;
 119          XDATA u32 usbcom_timeout;
 120          XDATA u8 usbcom_evtstate = 0;
 121          
 122          void usbcom_interrupt (void) interrupt UART1_VECTOR
 123          {
 124   1        //Tx uses polling mode, INT source can only be RX
 125   1      
 126   1          //Disable UART1 interrupt
 127   1          //(Rx uses interrupt to trigger, but still runs in polling mode)
 128   1      
 129   1          ES = 0;
 130   1      
 131   1          usbcom_rxcnt = 0;
 132   1          while(1)
 133   1          {
 134   2              RI = 0; //Remove RX end flag.
 135   2              usbcom_buf[usbcom_rxcnt++] = SBUF; //Retrieve byte.
 136   2      
 137   2              //Spin until RX end flag is set (by hardware)
 138   2              usbcom_timeout = 500;//You have to try out a proper value for specific baud and clock frequency se
             -ttings
 139   2              while(RI==0) 
 140   2              {
 141   3                  if(--usbcom_timeout == 0)
 142   3                      goto RX_END;
 143   3              }
 144   2          }
 145   1      
 146   1          RX_END:;
 147   1          
 148   1          TI = 0;  //Reset all flags
 149   1          RI = 0;
 150   1          ES = 1; //Enable UART1 interrupt
 151   1      
 152   1          usbcom_evtstate = 1;
 153   1      }
*** WARNING C291 IN LINE 115 OF src\usbcom.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    611    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    152    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
