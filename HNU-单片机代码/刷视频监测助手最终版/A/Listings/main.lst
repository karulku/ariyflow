C51 COMPILER V9.54   MAIN                                                                  09/18/2025 14:45:59 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\0_SoftWare\Keil5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include<STC15F2K60S2.H>
   2          #include"sys.h"
   3          #include"displayer.h"
   4          #include"Beep.h"
   5          #include"key.h"
   6          #include"ADC.h"
   7          #include"uart1.h"
   8          #include"uart2.h"
   9          #include"IR.h"
  10          #include"DS1302.h"
  11          #include"FM_Radio.h"
  12          #include"intrins.h"
  13          // ä¸‹ä½æœºç¨‹åº
  14          /*
  15          ç¼–ç è§„åˆ™ï¼š
  16            ç¬¬0,1å­—èŠ‚ä¸ºæ•°æ®åŒ…å¤´ï¼Œç¬¬2ä¸ªå­—èŠ‚æ ‡è¯†åŠŸèƒ½
  17            
  18            ç¬¬0,1å­—èŠ‚å›ºå®šä¸º10 29
  19            ç¬¬2å­—èŠ‚ä¸ºåŠŸèƒ½å­—èŠ‚ï¼š
  20              00 -- åˆ·è§†é¢‘åŠ©æ‰‹ï¼Œä¸‹ä½æœºä¸PCåŒå‘é€šä¿¡
  21                ç¬¬3ä¸ªå­—èŠ‚ä¸ºæŒ‡ä»¤
  22                  00 -- åˆ·æ–°é¡µé¢
  23                  ff -- é€€å‡ºè§†é¢‘ï¼ˆå¦‚æœæ‰“å¼€äº†è§†é¢‘ï¼Œæ²¡æœ‰æ‰“å¼€è§†é¢‘ä¼šç›´æ¥é€€å‡ºï¼‰
  24                  01 -- ç‚¹å¼€ç¬¬1ä¸ªè§†é¢‘ 02 -- ç‚¹å¼€ç¬¬2ä¸ªè§†é¢‘ 03 -- ç‚¹å¼€ç¬¬2ä¸ªè§†é¢‘
  25                  04 -- ç‚¹å¼€ç¬¬4ä¸ªè§†é¢‘ 05 -- ç‚¹å¼€ç¬¬5ä¸ªè§†é¢‘ 06 -- ç‚¹å¼€ç¬¬6ä¸ªè§†é¢‘
  26                  fe -- ç›´æ¥é€€å‡ºï¼Œä¸ç®¡æ˜¯å¦æ‰“å¼€è§†é¢‘
  27                  
  28                  æ¯”å¦‚ï¼š10 29 00 00 00 xx xx xx è¡¨ç¤ºåˆ·æ–°é¡µé¢
  29                
  30                ç¬¬4ä¸ªå­—èŠ‚ä¸ºå‰ç½®æŒ‡ä»¤
  31                  è¿™æ¡æŒ‡ä»¤ä¸º00æ—¶æ­£å¸¸å¤„ç†ç¬¬3ä¸ªå­—èŠ‚çš„æŒ‡ä»¤
  32                  è¿™æ¡æŒ‡ä»¤ä¸ä¸º00æ—¶ä¼šè§¦å‘å‰ç½®æŒ‡ä»¤æ“ä½œï¼š
  33                    01 -- æ‰“å¼€bç«™ï¼ˆä¸‹ä½æœº -> PCï¼‰  (10 29 00 xx 01 xx xx xx) è§¦å‘æ‰“å¼€bç«™äº‹ä»¶
  34                    
  35                    02 -- å…³é—­ä¸²å£ï¼ˆè¯¥åŠŸèƒ½åœ¨æ–°ç‰ˆä¸­å·²å¼ƒç”¨ï¼‰  (10 29 00 xx 02 xx xx xx)
  36                          å…³é—­å•ç‰‡æœºå’Œç”µè„‘çš„è¿æ¥ï¼Œæ…ç”¨ï¼Œå…³é—­ååªèƒ½ä»PCç«¯çš„ç¨‹åºæ‰“å¼€ä¸²å£
  37                          ç”±äºå…³é—­ä¸²å£å•ç‰‡æœºæ— æ³•æ“ä½œç¨‹åºï¼Œæ‰€ä»¥ç¨‹åºæ‰“å¼€åé»˜è®¤ä¼šæ‰“å¼€ä¸€æ¬¡ä¸²å£
  38                          å…³é—­åå•ç‰‡æœºæ— æ³•ä¸è®¡ç®—æœºé€šä¿¡ï¼Œæ‰€ä»¥æ— æ³•ä½¿ç”¨å•ç‰‡æœºå†æ¬¡æ‰“å¼€ä¸²å£
  39                          
  40                    03 -- æ—¶é—´ä¿¡å·ï¼ˆPC -> ä¸‹ä½æœºï¼‰ å‘é€æ—¶é—´ï¼Œæ­¤æ—¶ç¬¬5ï¼Œ6ï¼Œ7å­—èŠ‚è¡¨ç¤ºæ—¶ï¼Œåˆ†ï¼Œç§’
  41                          è¯¥ä¿¡å·åœ¨åˆ·è§†é¢‘ç»“æŸï¼ˆå…³é—­PCç¨‹åºæ—¶ï¼Œä¸å—è¶…æ—¶ä¿¡å·å½±å“ï¼‰è§¦å‘ï¼Œæ•°ç ç®¡æ˜¾
             -ç¤ºæ—¶-åˆ†-ç§’ï¼Œä¸Šä½æœºä¹Ÿä¼šåŒæ­¥æ˜¾ç¤º
  42                    
  43                    04 -- è¶…æ—¶ä¿¡å·ï¼ˆPC -> ä¸‹ä½æœºï¼‰ ç”±PCå‘é€æ¥çš„è¶…æ—¶ä¿¡å·ï¼Œä¸‹ä½æœºæ”¶åˆ°è¯¥ä¿¡å·åæŠ
             -¥è­¦ï¼Œå¹¶å°†ä¿¡å·ä¼ é€’ç»™ä¸‹ä½æœº
  44                          è¶…æ—¶æ—¶æ•°ç ç®¡ä¼šæ˜¾ç¤º 00-00-00
  45              ff -- ä¸Šä¸‹ä½æœºé€šä¿¡
  46                ä¸‹ä½æœºå‘ä¸Šä½æœºå‘é€æŒ‡ä»¤:
  47                  
  48            
  49            
  50          äº¤äº’åŠŸèƒ½ï¼š
  51            æ•°ç ç®¡6,7 -- æ˜¾ç¤ºè¦å‘é€çš„æŒ‡ä»¤
  52            key1 -- å‘é€å‰ç½®æŒ‡ä»¤æ‰“å¼€bç«™
C51 COMPILER V9.54   MAIN                                                                  09/18/2025 14:45:59 PAGE 2   

  53            key3 -- å‘é€æ•°æ®
  54            å¯¼èˆªä¸Šé”® -- æŒ‡ä»¤+1
  55            å¯¼èˆªä¸‹é”® -- æŒ‡ä»¤-1
  56            å¯¼èˆªä¸­é”® -- æ¸…0
  57            å¯¼èˆªå·¦é”® -- å…³é—­ä¸²å£
  58            
  59            æ³¨æ„åé¢å¯¹äºæ¨¡å¼çš„å®šä¹‰æœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯å•ç‰‡æœºå†…éƒ¨çš„æ¨¡å¼ï¼Œè¯¥æ¨¡å¼ç”±modeå®šä¹‰ï¼
             -Œå¦ä¸€ç§æ˜¯å•ç‰‡æœºä¸²å£é€šä¿¡çš„æ¨¡å¼ï¼Œè¯¥æ¨¡å¼ç”±bufç¼“å†²åŒºçš„ç¬¬2ä¸ªå­—èŠ‚å®šä¹‰
  60          */
  61          
  62          const unsigned char code DECODE_TABLE[] = { 
  63              0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, // 0-7
  64          //  0(0)  1(1)  2(2)  3(3)  4(4)  5(5)  6(6)  7(7)
  65              0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71, // 8-15
  66          //  8(8)  9(9)  a(10) b(11) c(12) d(13) e(14) f(15)
  67              0xBF, 0x86, 0xDB, 0xcF, 0xE6, 0xED, 0xFD, 0x87, // 16-23
  68          //  0.(16)1.(17)2.(18)3.(19)4.(20)5.(21)6.(22)7.(23)
  69              0xFF, 0xEF, 0x3d, 0x76, 0x0f, 0x0E, 0x75, 0x38, // 24-31
  70          //  8.(24)9.(25)G(26) H(27) I(28) J(29) K(30) L(31)
  71              0x37, 0x54, 0x5c, 0x73, 0x67, 0x31, 0x49, 0x78, // 32-39
  72          //  M(32) N(33) O(34) P(35) Q(36) R(37) S(38) T(39)
  73              0x3e, 0x1c, 0x7e, 0x64, 0x6e, 0x5a, 0x00, 0xFF,  // 40-47
  74          //  U(40) V(41) W(42) X(43) Y(44) Z(45) None  ALL
  75              0x40
  76          };
  77          
  78          #define uchar unsigned char
  79          
  80          code unsigned long SysClock=11059200;
  81          unsigned char local_addr = 0x01; // è¿™æ˜¯æœ¬æœºåœ°å€ï¼Œä¸å¯ä¿®æ”¹ï¼ï¼ï¼
  82          unsigned char uart_buf[8],receive_buf[8]; // ä¸²å£å‘é€å’Œæ¥æ”¶çš„ç¼“å†²åŒº
  83          unsigned char xdata seg[8] = {46,46,46,46,46,46,46,46}; // æ•°ç ç®¡æ˜¾ç¤ºå‘é‡
  84          unsigned char code uart_head[2] = {0x10,0x29}; // åŒ…å¤´
  85          unsigned char ir_buf[8]; // çº¢å¤–ç¼“å†²åŒº
  86          unsigned char adc_buf[8]; // ä¼ é€adcæ•°æ®çš„ä¸“ç”¨ç¼“å†²åŒº
  87          unsigned char mode = 0; // å…¨å±€æ¨¡å¼
  88          unsigned char clk_mode = 0; // æ—¶é’Ÿå†…éƒ¨çš„æ¨¡å¼
  89          struct_ADC adc; // adcå€¼
  90          struct_DS1302_RTC clk = {0x00,0x00,0x00,0x00,0x00,0x00,0x00}; // æ—¶é’Ÿä¿¡æ¯
  91          struct_FMRadio xdata fm = {918,5,0,0,0}; // æ”¶éŸ³æœºä¿¡æ¯
  92          unsigned char xdata fm_state = 0x00; // ä¿å­˜fmçš„çŠ¶æ€ï¼Œç¬¬0ä½æ ‡è¯†é¢‘ç‡æ˜¯å¦å¯è°ƒæ•´ï¼Œç¬¬1ä½æ 
             -‡è¯†éŸ³é‡æ˜¯å¦å¯è°ƒæ•´
  93          unsigned char xdata receive2_buf[8]; // ä¸²å£2çš„æ¥æ”¶ç¼“å†²åŒº
  94          
  95          void showSeg(){
  96   1        Seg7Print(seg[0],seg[1],seg[2],seg[3],seg[4],seg[5],seg[6],seg[7]);
  97   1      }
  98          
  99          void uartbufSet(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f, uchar g, uchar h){
 100   1        uart_buf[0]=a;
 101   1        uart_buf[1]=b;
 102   1        uart_buf[2]=c;
 103   1        uart_buf[3]=d;
 104   1        uart_buf[4]=e;
 105   1        uart_buf[5]=f;
 106   1        uart_buf[6]=g;
 107   1        uart_buf[7]=h;
 108   1      }
 109          
 110          void adcbufSet(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f, uchar g, uchar h){
 111   1        adc_buf[0]=a;
 112   1        adc_buf[1]=b;
C51 COMPILER V9.54   MAIN                                                                  09/18/2025 14:45:59 PAGE 3   

 113   1        adc_buf[2]=c;
 114   1        adc_buf[3]=d;
 115   1        adc_buf[4]=e;
 116   1        adc_buf[5]=f;
 117   1        adc_buf[6]=g;
 118   1        adc_buf[7]=h;
 119   1      }
 120          
 121          void segSet(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f, uchar g, uchar h){
 122   1        seg[0] = a;
 123   1        seg[1] = b;
 124   1        seg[2] = c;
 125   1        seg[3] = d;
 126   1        seg[4] = e;
 127   1        seg[5] = f;
 128   1        seg[6] = g;
 129   1        seg[7] = h;
 130   1      }
 131          
 132          void myDelay(unsigned char xms)   //@11.0592MHz
 133          {
 134   1        while(xms--){
 135   2          unsigned char i, j;
 136   2      
 137   2          _nop_();
 138   2          _nop_();
 139   2          _nop_();
 140   2          i = 11;
 141   2          j = 190;
 142   2          do
 143   2          {
 144   3            while (--j);
 145   3          } while (--i);
 146   2        }
 147   1      }
 148          
 149          void my100mSCallback(){
 150   1        LedPrint(mode+1);
 151   1        if(mode == 0){ // é»˜è®¤æ¨¡å¼
 152   2          if(uart_buf[2] == 0x00){ // è§†é¢‘åŠ©æ‰‹æ¨¡å¼
 153   3            segSet(46,46,46,46,46,46,(uart_buf[3]&0xf0)>>4, (uart_buf[3]&0x0f));
 154   3            // æµ‹è¯•ä»£ç ï¼Œåç»­åˆ é™¤
 155   3            // segSet((uart_buf[4]&0xf0)>>4, (uart_buf[4]&0x0f),(uart_buf[5]&0xf0)>>4, (uart_buf[5]&0x0f),(uart_buf
             -[6]&0xf0)>>4, (uart_buf[6]&0x0f),(uart_buf[7]&0xf0)>>4, (uart_buf[7]&0x0f));
 156   3          }
 157   2          else if(uart_buf[2] == 0xff){ // åŒæœºé€šä¿¡æ¨¡å¼
 158   3            if(receive_buf[3] == 0x00){
 159   4              segSet(receive_buf[5]/10,receive_buf[5]%10,48,receive_buf[6]/10,receive_buf[6]%10,48,receive_buf[7]/10
             -,receive_buf[7]%10);
 160   4            }
 161   3            else if(receive_buf[3] == 0x01){
 162   4              uartbufSet(0x10,0x29,0xff,0x01,0x00,0x00,0x00,0x00);
 163   4              Uart1Print(uart_buf, 8);
 164   4            }
 165   3          }
 166   2        }
 167   1        
 168   1        if(mode == 1){ // å¦‚æœæ˜¯æ—¶é’Ÿæ¨¡å¼
 169   2          clk = RTC_Read();
 170   2          if(clk_mode == 0){
 171   3            segSet(clk.hour>>4,clk.hour&0x0f,48,clk.minute>>4,clk.minute&0x0f,48,clk.second>>4,clk.second&0x0f);
 172   3            showSeg();
C51 COMPILER V9.54   MAIN                                                                  09/18/2025 14:45:59 PAGE 4   

 173   3          }
 174   2          else if(clk_mode == 1){
 175   3            segSet(clk.year>>4,clk.year&0x0f,48,clk.month>>4,clk.month&0x0f,48,clk.day>>4,clk.day&0x0f);
 176   3            showSeg();
 177   3          }
 178   2          else if(clk_mode == 2){
 179   3            segSet(48,48,48,48,48,48,clk.week>>4,clk.week&0x0f);
 180   3            showSeg();
 181   3          }
 182   2        }
 183   1        
 184   1        if(mode == 2){ // æ”¶éŸ³æœºæ¨¡å¼
 185   2          segSet(48,fm.frequency/100,fm.frequency/10%10+16,fm.frequency%10,48,48,fm.volume/10,fm.volume%10);
 186   2          showSeg();
 187   2        }
 188   1        
 189   1        showSeg();
 190   1      }
 191          
 192          void myKeyCallback(){
 193   1        unsigned char key;
 194   1        
 195   1        key = GetKeyAct(enumKey2);
 196   1        if(key == enumKeyPress){
 197   2          mode = (mode+1)%3;
 198   2          
 199   2          // è¿™é‡Œæ”¾modeåˆ‡æ¢åéœ€è¦æ‰§è¡Œçš„æ“ä½œ
 200   2          if(mode == 1){
 201   3            clk_mode = 0;
 202   3          }
 203   2          
 204   2          if(mode == 0){
 205   3            // æ³¨æ„è¿™é‡Œï¼Œåœ¨å‘é€å®Œæ¯•ä¹‹åï¼Œéœ€è¦æŠŠuart_buf[2]åˆ‡æ¢å›0x00ï¼Œå¦åˆ™ä¼šå‡ºç°é—®é¢˜ï¼ˆs
             -hitå±±ä»£ç ï¼‰
 206   3            uart_buf[2] = 0x00;
 207   3            fm_state = 0x00;
 208   3          }
 209   2        }
 210   1        
 211   1        if(mode == 0){
 212   2          if(uart_buf[2] == 0x00){
 213   3            key = GetKeyAct(enumKey1);
 214   3            if(key == enumKeyPress){
 215   4              uartbufSet(0x10,0x29,0x00,0x00,0x01,0x00,0x00,0x00);
 216   4              Uart1Print(uart_buf, 8);
 217   4            }
 218   3          }
 219   2        }
 220   1      
 221   1        if(mode == 1){ // æ—¶é’Ÿæ¨¡å¼ä¸‹
 222   2          key = GetKeyAct(enumKey1); // æŒ‰ä¸‹key1é”®åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼
 223   2          if(key == enumKeyPress){
 224   3            clk_mode = (clk_mode+1)%3;
 225   3          }
 226   2        }
 227   1        
 228   1        if(mode == 2){ // æ”¶éŸ³æœºæ¨¡å¼
 229   2          key = GetKeyAct(enumKey1); // key1æ—¶æ§åˆ¶éŸ³é‡
 230   2          if(key == enumKeyPress){
 231   3            if((fm_state&0x02) != 0x02)fm_state = (fm_state ^ 0x01); // å¦‚æœæ­£åœ¨è°ƒæ•´é¢‘ç‡ï¼ŒæŒ‡ä»¤æ— æ•ˆ
 232   3            if((fm_state&0x01) == 0x01){ // æŒ‰ä¸‹åçŠ¶æ€ä¸ºè°ƒæ•´éŸ³é‡ï¼Œè§¦å‘ä¸€æ¬¡æç¤ºéŸ³
 233   4              SetBeep(800, 20);
C51 COMPILER V9.54   MAIN                                                                  09/18/2025 14:45:59 PAGE 5   

 234   4            }
 235   3            else{ // æŒ‰ä¸‹åä¸ºè°ƒæ•´å®Œæˆï¼Œè§¦å‘å¦ä¸€ä¸ªæç¤ºéŸ³
 236   4              uartbufSet(0x10,0x29,0x01,0x01,(fm.frequency>>8),(fm.frequency&0x00ff),fm.volume,0x00);
 237   4              Uart1Print(uart_buf, 8);
 238   4              SetBeep(600,20);
 239   4            }
 240   3          }
 241   2        }
 242   1      }
 243          
 244          void myADCCallback(){
 245   1        unsigned char key;
 246   1        if(mode == 0){ // mode 0ï¼šæ§åˆ¶ä¸²å£å‘é€
 247   2          if(uart_buf[2] == 0x00){
 248   3            key = GetAdcNavAct(enumAdcNavKey3);
 249   3            if(key == enumKeyPress){
 250   4              uartbufSet(0x10,0x29,0x00,uart_buf[3],0x00,0x00,0x00,0x00);
 251   4              Uart1Print(uart_buf, 8);
 252   4            }
 253   3            key = GetAdcNavAct(enumAdcNavKeyUp);
 254   3            if(key == enumKeyPress){
 255   4              uart_buf[3]++;
 256   4            }
 257   3            key = GetAdcNavAct(enumAdcNavKeyDown);
 258   3            if(key == enumKeyPress){
 259   4              uart_buf[3]--;
 260   4            }
 261   3            key = GetAdcNavAct(enumAdcNavKeyCenter);
 262   3            if(key == enumKeyPress){
 263   4              uart_buf[3] = 0x00;
 264   4            }
 265   3          }
 266   2        }
 267   1        
 268   1        if(mode == 2){ // æ”¶éŸ³æœºæ¨¡å¼ä¸‹ï¼Œå¦‚æœfm_stateå¯¹åº”ä½ä¸º1ï¼Œè°ƒæ•´é¢‘ç‡æˆ–éŸ³é‡
 269   2          key = GetAdcNavAct(enumAdcNavKey3);
 270   2          if(key == enumKeyPress){
 271   3            if((fm_state&0x01) != 0x01)fm_state = (fm_state ^ 0x02); // å¦‚æœæ­£åœ¨è°ƒæ•´éŸ³é‡ï¼ŒæŒ‡ä»¤æ— æ•ˆ
 272   3            if((fm_state&0x02) == 0x02){
 273   4              SetBeep(800,20);
 274   4            }
 275   3            else{
 276   4              uartbufSet(0x10,0x29,0x01,0x01,(fm.frequency>>8),(fm.frequency&0x00ff),fm.volume,0x00);
 277   4              Uart1Print(uart_buf, 8);
 278   4              SetBeep(600,20);
 279   4            }
 280   3          }
 281   2          
 282   2          key = GetAdcNavAct(enumAdcNavKeyUp);
 283   2          if(key == enumKeyPress){
 284   3            if((fm_state&0x01) == 0x01){
 285   4              if(fm.volume<15)fm.volume = fm.volume+1;
 286   4            }
 287   3            else if((fm_state&0x02) == 0x02){
 288   4              if(fm.frequency<1080)fm.frequency = fm.frequency+1;
 289   4            }
 290   3          }
 291   2          
 292   2          key = GetAdcNavAct(enumAdcNavKeyDown);
 293   2          if(key == enumKeyPress){
 294   3            if((fm_state&0x01)==0x01){
 295   4              if(fm.volume>0)fm.volume = fm.volume-1;
C51 COMPILER V9.54   MAIN                                                                  09/18/2025 14:45:59 PAGE 6   

 296   4            }
 297   3            else if((fm_state&0x02)==0x02){
 298   4              if(fm.frequency>887)fm.frequency = fm.frequency-1;
 299   4            }
 300   3          }
 301   2          SetFMRadio(fm);
 302   2        }
 303   1      
 304   1      }
 305          
 306          void myUart1Callback(){
 307   1        char state;
 308   1        uart_buf[2] = receive_buf[2]; // æ¨¡å¼åˆ‡æ¢
 309   1        LedPrint(uart_buf[2]);
 310   1      
 311   1        
 312   1        if(receive_buf[2] == 0x00){ // åˆ·è§†é¢‘æ¨¡å¼ï¼Œæ¥æ”¶ä»PCä¼ æ¥çš„è¶…æ—¶ä¿¡å·å’Œæ—¶é—´ä¿¡å·
 313   2          if(receive_buf[4] == 0x03){ // æ”¶åˆ°ç»“æŸä¿¡å·ï¼Œä¼ é€’åˆ·è§†é¢‘çš„æ—¶é—´
 314   3            // è¿™é‡Œå¤„ç†ä¼ é€’é€»è¾‘
 315   3            uartbufSet(0x10,0x29,0xff,0x00,local_addr,receive_buf[5],receive_buf[6],receive_buf[7]);
 316   3            Uart2Print(uart_buf, 8);
 317   3          }
 318   2          else if(receive_buf[4] == 0x04){ // è¶…æ—¶ä¿¡å·ï¼ŒæŠ¥è­¦æé†’ï¼Œå¹¶å°†ä¿¡å·ä¼ é€’ç»™ä¸Šä½æœº
 319   3            SetBeep(1200,100);
 320   3            uartbufSet(0x10,0x29,0xff,0x01,local_addr,0x00,0x00,0x00);
 321   3            Uart2Print(uart_buf, 8);
 322   3            state = GetUart2TxStatus();
 323   3            if(state == enumUart1TxFree){
 324   4              uart_buf[2] = 0x00;
 325   4            }
 326   3          }
 327   2        }
 328   1        
 329   1        if(receive_buf[2] == 0x01){ // è¾…åŠ©åŠŸèƒ½ï¼Œç›®å‰åªæä¾›åŒæ­¥æ—¶é’Ÿ
 330   2          if(receive_buf[3] == 0x01){ // PCä¼ é€’æ—¶é’Ÿä¿¡æ¯
 331   3            if(receive_buf[4] == 0x00){ // å¹´æœˆæ—¥
 332   4              clk = RTC_Read();
 333   4              clk.year = ((receive_buf[5]/10)<<4)+(receive_buf[5]%10);
 334   4              clk.month = ((receive_buf[6]/10)<<4)+(receive_buf[6]%10);
 335   4              clk.day = ((receive_buf[7]/10)<<4)+(receive_buf[7]%10);
 336   4              RTC_Write(clk);
 337   4            }
 338   3            else if(receive_buf[4] == 0x01){ // æ—¶åˆ†ç§’
 339   4              clk = RTC_Read();
 340   4              clk.hour = ((receive_buf[5]/10)<<4)+(receive_buf[5]%10);
 341   4              clk.minute = ((receive_buf[6]/10)<<4)+(receive_buf[6]%10);
 342   4              clk.second = ((receive_buf[7]/10)<<4)+(receive_buf[7]%10);
 343   4              RTC_Write(clk);
 344   4            }
 345   3            else if(receive_buf[4] == 0x02){ // æ˜ŸæœŸ
 346   4              clk = RTC_Read();
 347   4              clk.week = ((receive_buf[5]/10)<<4)+(receive_buf[5]%10+1);
 348   4              RTC_Write(clk);
 349   4            }
 350   3          }
 351   2        }
 352   1      
 353   1      }
 354          
 355          void myUart2Callback(){
 356   1        if(receive2_buf[2] == 0x02){ // ä¸Šä½æœºç›´æ¥å’ŒPCé€šä¿¡ï¼Œç›´æ¥å‘åˆ°ä¸²å£1
 357   2          Uart1Print(receive2_buf, 8);
C51 COMPILER V9.54   MAIN                                                                  09/18/2025 14:45:59 PAGE 7   

 358   2        }
 359   1      }
 360          
 361          void myIRCallback(){
 362   1        if((ir_buf[0] == 0x10) && (ir_buf[1] == 0x29)){
 363   2          if((ir_buf[2] == 0xff) && (ir_buf[4] == local_addr)){
 364   3            if(ir_buf[3] == 0x02){ // å¼ºåˆ¶åœæœºæŒ‡ä»¤
 365   4              uartbufSet(0x10,0x29,0x00,0xfe,0x00,0x00,0x00,0x00);
 366   4              Uart1Print(uart_buf, 8); // éœ€è¦æ·»åŠ åœæœºé€»è¾‘
 367   4            }
 368   3          }
 369   2        }
 370   1      }
 371          
 372          unsigned char xdata adc_turn = 0;
 373          void my1SCallback(){
 374   1        // è¿™é‡Œå‘é€adcå€¼
 375   1        
 376   1        adc = GetADC();
 377   1        if(adc_turn){
 378   2          adcbufSet(0x10,0x29,0x01,0x00,0x00,(adc.Rop>>8),(adc.Rop&0x00ff),0x00);
 379   2          Uart1Print(adc_buf, 8);
 380   2        }
 381   1        else{
 382   2          adcbufSet(0x10,0x29,0x01,0x00,0x01,(adc.Rt>>8),(adc.Rt&0x00ff),0x00);
 383   2          Uart1Print(adc_buf, 8);
 384   2        }
 385   1        adc_turn = (1 - adc_turn);
 386   1        
 387   1      }
 388          
 389          void main(){
 390   1        MySTC_Init();
 391   1        DisplayerInit();
 392   1        BeepInit();
 393   1        KeyInit();
 394   1        AdcInit(ADCexpEXT);
 395   1        IrInit(NEC_R05d);
 396   1        Uart1Init(9600);
 397   1        Uart2Init(9600, Uart2Usedfor485);
 398   1        DS1302Init(clk);
 399   1        FMRadioInit(fm);
 400   1        
 401   1        SetUart1Rxd(receive_buf, 8, uart_head, 2);
 402   1        SetUart2Rxd(receive2_buf, 8, uart_head, 2);
 403   1        SetIrRxd(ir_buf, 8);
 404   1        Seg7Print(46,46,46,46,46,46,46,46);
 405   1        LedPrint(0);
 406   1        
 407   1        SetEventCallBack(enumEventSys100mS,my100mSCallback);
 408   1        SetEventCallBack(enumEventKey,myKeyCallback);
 409   1        SetEventCallBack(enumEventXADC,myADCCallback);
 410   1        SetEventCallBack(enumEventUart1Rxd, myUart1Callback);
 411   1        SetEventCallBack(enumEventUart2Rxd, myUart2Callback);
 412   1        SetEventCallBack(enumEventIrRxd, myIRCallback);
 413   1        SetEventCallBack(enumEventSys1S, my1SCallback);
 414   1        while(1){
 415   2          MySTC_OS();
 416   2        }
 417   1      }


C51 COMPILER V9.54   MAIN                                                                  09/18/2025 14:45:59 PAGE 8   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1876    ----
   CONSTANT SIZE    =     55    ----
   XDATA SIZE       =     24    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     52      28
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
